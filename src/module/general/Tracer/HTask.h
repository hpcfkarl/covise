/* This file is part of COVISE.

   You can use it under the terms of the GNU Lesser General Public License
   version 2.1 or later, see lgpl-2.1.txt.

 * License: LGPL 2+ */

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  CLASS HTask
//
//  Base class for all classes that handle bundles of ptasks (i.e. different tracelines)
//
//  Initial version: 2001-12-07 Sergio Leseduarte
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//  (C) 2001 by VirCinity IT Consulting
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Changes:

#ifndef _H_TASK_H_
#define _H_TASK_H_

#include "PTask.h"
#include <api/coModule.h>
using namespace covise;
#include <float.h>

class BBoxAdmin;

int ExpandSetList(const coDistributedObject *const *objects, int h_many,
                  std::vector<const coDistributedObject *> &out_array);

/**
 * An object of this class manages all PTasks: PTask creation, assignation
 * to threads, and gathering of PTask results.
 */
class HTask
{
public:
    /** Constructor
       * @param name_line name for line
       * @param name_magnitude name for magnitude object
       * @param grid grid object
       * @param velo velocity object
       * @param ini_p initial points object
       */
    HTask(const coModule *mod,
          const char *name_line, const char *name_magnitude,
          const coDistributedObject *grid, const coDistributedObject *velo,
          const coDistributedObject *ini_p);

    /** Use when no threads are used. PTasks are solved sequentially.
       * @param    eps      relative error per time step for step control.
       * @param    eps_abs  absolute error per time step for step control.
       */
    void Solve(float epsilon, float epsilon_abs);
    /** Return 1 if all PTasks have been finished, 0 otherwise.
       * @return            all PTasks have been finished or not.
       */
    virtual int allPFinished();
    /** Return 1 if there are still PTasks to be assigned to a thread.
       * @return            all PTasks have been assigned to a thread.
       */
    int unserviced();
    /** Assign a task to a thread reading tasks from "port" *pp_task
       * @retval   pp_task address of pointer to the assigned PTask.
       * @param    label   thread identification.
       */
    void assignTask(PTask **pp_task, int label);
    /** Do whatever is necessary when a PTask is done.
       * @retval   pp_task set the pointer to assigned task to zero.
       */
    void gatherPTask(PTask **pp_task);
    /** Return 1 if all time steps are done.
       * @return            all time steps are done.
       */
    virtual int Finished() = 0;
    /** Called every time step to create new PTasks if necessary.
       */
    virtual void createPTasks() = 0;
/** Gather results from all PTasks after a time step.
       */
    virtual void gatherTimeStep() = 0;
    /** Gather results from all all time steps.
       * @param    p_line   pointer to line output port.
       * @param    p_mag    pointer to magnitude output port.
       */
    virtual void gatherAll(coOutputPort *p_line, coOutputPort *p_mag) = 0;
    /** Destroy PTasks generated by this HTask.
       */
    void cleanPTasks();
    /** Check if inputs for construction were OK.
       * @return            0 if OK, -1 otherwise.
       */
    virtual int Diagnose();
    /** Check if coDoPoints inputs for construction were OK.
       * @return            0 if OK, -1 otherwise.
       */
    virtual int DiagnosePoints();
    /// Warn if an initial point lies out of the domain
    virtual void WarnIfOutOfDomain() = 0;
    // Destructor.
    virtual ~HTask();
    /** Check if inputs are dynamic or static.
       * @return            1 if yes, 0 otherwise.
       */
    int hasTimeSteps();
    /// AssignOctTrees uses a BBoxAdmin object to assign
    /// octrees to the grids referenced by means of grid_tstep_opt_
    void AssignOctTrees(const BBoxAdmin *);
    enum time_direction
    {
        FORWARDS,
        BACKWARDS,
        BOTH
    };

protected:
    const coModule *module_; // for sending ui messages
    int no_steps_; // number of time steps
    int no_ptasks_; // number of ptasks for the actual time step
    PTask **ptasks_; // list of pointers to
    // ptasks_ objects,
    // which are created for every time step
    // it is always true that serviced_>=no_finished_
    int no_finished_; // start with 0 for every time step
    int serviced_; // start with 0 for every time step
    const coDistributedObject *grid_; // pointer to grid input object
    const coDistributedObject *velo_; // pointer to velocity input object
    const coDistributedObject *ini_p_; // pointer to initial point object
    std::vector<const coDistributedObject *> grid_tstep0_; // objects for the actual time step
    std::vector<const coDistributedObject *> velo_tstep0_;
    std::vector<const coDistributedObject *> inip_tstep0_;

    const char *name_line_; // names for output objects
    const char *name_magnitude_;
    // used for getting object lists for a given time step
    void ExpandGridObjects(int covise_time, std::vector<const coDistributedObject *> &grid_tstep0);
    void ExpandVeloObjects(int covise_time, std::vector<const coDistributedObject *> &grid_tstep0);
    void ExpandInipObjects(int covise_time, std::vector<const coDistributedObject *> &grid_tstep0);
    // list of lists (each entry corresponds to a time step)
    std::vector<std::vector<const coDistributedObject *> > grid_tstep_opt_;
    std::vector<const coDistributedObject *> *velo_tstep_opt_;
    int num_velo_steps_;
    std::vector<const coDistributedObject *> *inip_tstep_opt_;
    int num_inip_steps_;

    // extracts the real time for a discrete time
    float realTime(const coDistributedObject *, const coDistributedObject *, int);
    void fillRealTime();
    std::vector<float> realTimes_; // array of real times for all discrete times

private:
    float realTimeInt(const coDistributedObject *, const coDistributedObject *, int);
    void MakeIAsForExpand();
};
#endif
